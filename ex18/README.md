# 函数指针

## 扩展思维

Rust里面没有函数指针的概念，是如何做到把函数当作参数传递的呢？

答案： 闭包。

Rust代码示例：

```
fn funTest(value: i32, f: &Fn(i32) -> i32) -> i32 {
    println!("{}", f(value));
    value
}

fn times2(value: i32) -> i32 {
    2 * value
}

fn main() {
    funTest(5, &times2);
}

```



## 函数指针的应用

函数指针有那么复杂吗？当然不是，任何一个稍有编程常识的人，不管他懂不懂C语言，在10分钟内，我想他一定可以明白C语言中的函数指针是怎么回事。

原因在于，难的不是函数指针的概念和语法本身，而是在什么时候，什么地方该使用它。函数指针不仅是语法上的问题，更重要的是它是一个设计范畴。真正的高手当然不单应该懂得语法层面上的技巧，更应该懂得设计上的方法。不懂设计，能算高手吗？怀疑我在夸大其辞吗？那我们先看看函数指针与哪些设计方法有关：

与分层设计有关。分层设计早就不是什么新的概念，分层的好处是众所周知的，比较明显好处就是简化复杂度、隔离变化。采用分层设计，每层都只需关心自己的东西，这减小了系统的复杂度，层与层之间的交互仅限于一个很窄的接口，只要接口不变，某一层的变化不会影响其它层，这隔离了变化。

分层的一般原则是，上层可以直接调用下层的函数，下层则不能直接调用上层的函数。这句话说来简单，在现实中，下层常常要反过来调用上层的函数。比如你在拷贝文件时，在界面层调用一个拷贝文件函数。界面层是上层，拷贝文件函数是下层，上层调用下层，理所当然。但是如果你想在拷贝文件时还要更新进度条，问题就来了。一方面，只有拷贝文件函数才知道拷贝的进度，但它不能去更新界面的进度条。另外一方面，界面知道如何去更新进度条，但它又不知道拷贝的进度。怎么办？常见的做法，就是界面设置一个回调函数给拷贝文件函数，拷贝文件函数在适当的时候调用这个回调函数来通知界面更新状态。

与抽象有关。抽象是面向对象中最重要的概念之一，也是面向对象威力强大之处。面向对象只是一种思想，大家都知道，用C语言一样可以实现面向对象的编程。这可不是为了赶时髦，而是一种实用的方法。如果你对此表示怀疑，可以去看看GTK+、linux kernel等开源代码。

接口是最高级的抽象。在linux kernel里面，接口的概念无处不在，像虚拟文件系统(VFS)，它定义一个文件系统的接口，只要按照这种接口的规范，你可以自己开发一个文件系统挂上去。设备驱动程序更是如此，不同的设备驱动程序有自己一套不同的接口规范。在自己开发设备开发驱动程序时，只要遵循相应的接口规范就行了。接口在C语言中如何表示？很简单，就是一组函数指针。

与接口与实现分开有关。针对接口编程，而不是针对实现编程，此为《设计模式》的第一条设计准则。分开接口与实现的目标是要隔离变化。软件是变化的，如果不能把变化的东西隔离开来，导致牵一发而动全身，代价是巨大的。这是大家所不愿看到的。

C语言既然可以实现面向对象的编程，自然可以利用设计模式来分离接口与实现。像桥接模式、策略模式、状态模式、代理模式等等，在C语言中，无一不需要利用函数指针来实现。

与松耦合原则有关。面向过程与面向对象相比，之所以显得苍白无力，原因之一就是它不像面向对象一样，可以直观的把现实模型映射到计算机中。面向过程讲的是层层控制，而面向对象更强调的对象间的分工合作。现实世界中的对象处于层次关系的较少，处于对等关系的居多。也就是说，对象间的交互往往是双向的。这会加强对象间的耦合性。

耦合本身没有错，实际上耦合是必不可少的，没有耦合就没有协作，对象之间无法形成一个整体，什么事也做不了。关键在于耦合要恰当，在实现预定功能的前提下，耦合要尽可能的松散。这样，系统的一部分变化对其它部分的影响会很少。

函数指针是解耦对象关系的最佳利器。Signal(如boost的signal和glib中的signal)机制是一个典型的例子，一个对象自身的状态可能是在变化的（或者会触发一些事件），而其它对象关心它的变化。一旦该对象有变化发生，其它对象要执行相应的操作。

如果该对象直接去调用其它对象的函数，功能是完成了，但对象之间的耦合太紧了。如何把这种耦合降到最低呢，signal机制是很好的办法。它的原理大致如下：其它关注该对象变化的对象主动注册一个回调函数到该对象中。一旦该对象有变化发生，就调用这些回调函数通知其它对象。功能同样实现了，但它们之间的耦合度降低了。

在C语言中，要解决以上这些问题，不采用函数指针，将是非常困难的。在编程中，如果你从没有想到用函数指针，很难想像你是一个C语言高手。

##函数指针概念

### 函数指针和一个简单的函数

我们从一个非常简单的Hello World函数入手，来见识一下怎样创建一个函数指针。

```
#include <stdio.h>

// 函数原型
void sayHello();

//函数实现
void sayHello(){
    printf("hello world\n");
}

// main函数调用
int main() {
    sayHello();
}

```

我们定义了一个名为sayHello的函数，它没有返回值也不接受任何参数。当我们在main函数中调用它的时候，它向屏幕输出出”hello world“。非常简单。接下来，我们改写一下main函数，之前直接调用的sayHello函数，现在改用函数指针来调用它。

```

int main() {
    void (*sayHelloPtr)() = sayHello;
    (*sayHelloPtr)();
}

```

第二行`void (*sayHelloPtr)()`的语法看起来有些奇怪，我们来一步一步分析。

1. 这里，关键字void的作用是说我们创建了一个函数指针，并让它指向了一个返回void（也就是没有返回值）的函数。
2. 就像其他任何指针都必须有一个名称一样，这里sayHelloPtr被当作这个函数指针的名称。
3. 我们用`*`符号来表示这是一个指针，这跟声明一个指向整数或者字符的指针没有任何区别。
4. `*sayHelloPtr`两端的括号是必须的，否则，上述声明变成`void *sayHelloPtr()`，`*`会优先跟void结合，变成了一个返回指向void的指针的普通函数的声明。因此，函数指针声明的时候不要忘记加上括号，这非常关键。
5. 参数列表紧跟在指针名之后，这个例子中由于没有参数，所以是一对空括号()。
6. 将上述要点结合起来，`void (*syaHelloPtr)()`的意义就非常清楚了，这是一个函数指针，它指向一个不接收参数且没有返回值的函数。

在上面的第二行代码，即`void (*sayHelloPtr)() = sayHello;`，我们将sayHello这个函数名赋给了我们新建的函数指针。关于函数名的更多细节我们会在下文中讨论，现在暂时可以将其看作一个标签，它代表函数的地址，并且可以赋值给函数指针。这就跟语句`int *x = &myint;`中我们把myint的地址赋给一个指向整数的指针一样。只是当我们考虑函数的时候，我们不需要加上一个取地址符&。简而言之，函数名就是它的地址。接着看第三行，我们用代码`(*sayHelloPtr)();`解引用并调用了函数指针。

1. 在第二行被声明之后，sayHelloPtr作为函数指针的名称，跟其他任何指针没有差别，能够储值和赋值。
2. 我们对sayHelloPtr解引用的方式也与其他任何指针一样，即在指针之前使用解引用符*，也就是代码中的`*sayHelloPtr`。
3. 同样的，我们需要在其两端加上括号，即`(*sayHelloPtr)`，否则它就不被当做一个函数指针。因此，记得声明和解引用的时候都要在两端加上括号。
4. 括号操作符用于C语言中的函数调用，如果有参数参与，就将其放入括号中。这对于函数指针也是相似的，即代码中的`(*sayHelloPtr)()`。
5. 这个函数没有返回值，也就没有必要将它赋值给任何变量。单独来说，这个调用跟sayHello()没什么两样。
接下来，我们再对函数稍加修改。你会看到函数指针奇怪的语法，以及用调用普通函数的方法来调用赋值后函数指针的现象。

```
int main() {
    void (*sayHelloPtr)() = sayHello;
    sayHelloPtr();
}
```

跟之前一样，我们将sayHello函数赋给函数指针。但是这一次，我们用调用普通函数的方法调用了它。稍后讨论函数名的时候我会解释这一现象，现在只需要知道`(*syaHelloPtr)()和syaHelloPtr()`是相同的即可。


### 带参数的函数指针

好了，这一次我们来创建一个新的函数指针吧。它指向的函数仍然不返回任何值，但有了参数。

```
#include <stdio.h>

//函数原型
void subtractAndPrint(int x, int y);

//函数实现
void subtractAndPrint(int x, int y) {
    int z = x - y;
    printf("Simon says, the answer is: %d\n", z);
}

//main函数调用
int main() {
    void (*sapPtr)(int, int) = subtractAndPrint;
    (*sapPtr)(10, 2);
    sapPtr(10, 2);
}
```

跟之前一样，代码包括函数原型，函数实现和在main函数中通过函数指针执行的语句。原型和实现中的特征标变了，之前的sayHello函数不接受任何参数，而这次的函数subtractAndPrint接受两个int作为参数。它将两个参数做一次减法，然后输出到屏幕上。

1. 在第14行，我们通过`(*sapPtr)(int, int)`创建了sapPtr这个函数指针，与之前的区别仅仅是用(int, int)代替了原来的空括号。而这与新函数的特征标相符。
2. 在第15行，解引用和执行函数的方式与之前完全相同，只是在括号中加入了两个参数，变成了(10, 2)。
3. 在第16行，我们用调用普通函数的方法调用了函数指针。


### 带参数且有返回值的函数指针

这一次，我们把subtractAndPrint函数改成一个名为subtract的函数，让它把原本输出到屏幕上的结果作为返回值。

```
#include <stdio.h>

// 函数原型
int subtract(int x, int y);

// 函数实现
int subtract(int x, int y) {
    return x - y;
}

// main函数调用
int main() {
  int (*subtractPtr)(int, int) = subtract;

  int y = (*subtractPtr)(10, 2);
  printf("Subtract gives: %d\n", y);

  int z = subtractPtr(10, 2);
  printf("Subtract gives: %d\n", z);
}
```

这与subtractAndPrint函数非常相似，只是subtract函数返回了一个整数而已，特征标也理所当然的不一样了。

1. 在第13行，我们通过`int (*subtractPtr)(int, int)`创建了subtractPtr这个函数指针。与上一个例子的区别只是把void换成了int来表示返回值。而这与subtract函数的特征标相符。
2. 在在第15行，解引用和执行这个函数指针，除了将返回值赋值给了y以外，与调用subtractAndPrint没有任何区别。
3. 在第16行，我们向屏幕输出了返回值。
4. 18到19行，我们用调用普通函数的方法调用了函数指针，并且输出了结果。

这跟之前没什么两样，我们只是加上了返回值而已。接下来我们看看另一个稍微复杂点儿的例子——把函数指针作为参数传递给另一个函数。

### 把函数指针作为参数来传递

我们已经了解过了函数指针声明和执行的各种情况，不论它是否带参数，或者是否有返回值。接下来我们利用一个函数指针来根据不同的输入执行不同的函数。

```
#include <stdio.h>

// 函数原型
int add(int x, int y);
int subtract(int x, int y);
int domath(int (*mathop)(int, int), int x, int y);

// 加法 x+ y
int add(int x, init y) {
    return x + y;
}

// 减法 x - y
int subtract(int x, int y) {
    return x - y;
}

// 根据输入执行函数指针
int domath(int (*mathop)(int, int), int x, int y) {
    return (*mathop)(x, y);
}

// main函数调用
int main() {

    // 用加法调用domath
    int a = domath(add, 10, 2);
    printf("Add gives: %d\n", a);

    // 用减法调用domath
    int b = domath(subtract, 10, 2);
    printf("Subtract gives: %d\n", b);
}
```

我们来一步一步分析。

1. 我们有两个特征标相同的函数，add和subtract，它们都返回一个整数并接受两个整数作为参数。
2. 在第六行，我们定义了函数`int domath(int (*mathop)(int, int), int x, int y)`。它第一个参数`int (*mathop)(int, int)`是一个函数指针，指向返回一个整数并接受两个整数作为参数的函数。这就是我们之前见过的语法，没有任何不同。它的后两个整数参数则作为简单的输入。因此，这是一个接受一个函数指针和两个整数作为参数的函数。
3. 19到21行，domath函数将自己的后两个整数参数传递给函数指针并调用它。当然，也可以像这么调用。mathop(x, y);
4. 27到31行出现了我们没见过的代码。我们用函数名作为参数调用了domath函数。就像我之前说过的，函数名是函数的地址，而且能代替函数指针使用。

main函数调用了两次domath函数，一次用了add，一次用了subtract，并输出了这两次结果。


### 函数名和地址

既然有约在先，那我们就讨论一下函数名和地址作为结尾吧。一个函数名（或称标签），被转换成了一个指针本身。这表明在函数指针被要求当作输入的地方，就能够使用函数名。这也导致了一些看起来很糟糕的代码却能够正确的运行。瞧瞧下面这个例子。

```
#include <stdio.h>

// 函数原型
void add(char *name, int x, int y);

// 加法 x + y
void add(char *name, int x, int y) {
    printf("%s gives: %d\n", name, x + y);
}

// main函数调用
int main() {

    // 一些糟糕的函数指针赋值
    void (*add1Ptr)(char*, int, int) = add;
    void (*add2Ptr)(char*, int, int) = *add;
    void (*add3Ptr)(char*, int, int) = &add;
    void (*add4Ptr)(char*, int, int) = **add;
    void (*add5Ptr)(char*, int, int) = ***add;

    // 仍然能够正常运行
    (*add1Ptr)("add1Ptr", 10, 2);
    (*add2Ptr)("add2Ptr", 10, 2);
    (*add3Ptr)("add3Ptr", 10, 2);
    (*add4Ptr)("add4Ptr", 10, 2);
    (*add5Ptr)("add5Ptr", 10, 2);

    // 当然，这也能运行
    add1Ptr("add1PtrFunc", 10, 2);
    add2Ptr("add2PtrFunc", 10, 2);
    add3Ptr("add3PtrFunc", 10, 2);
    add4Ptr("add4PtrFunc", 10, 2);
    add5Ptr("add5PtrFunc", 10, 2);
}
```

这是一个简单的例子。运行这段代码，你会看到每个函数指针都会执行，只是会收到一些关于字符转换的警告。但是，这些函数指针都能正常工作。

1. 在第15行，add作为函数名，返回这个函数的地址，它被隐式的转换为一个函数指针。我之前提到过，在函数指针被要求当作输入的地方，就能够使用函数名。
2. 在第16行，解引用符作用于add之前，即*add，在返回在这个地址的函数。之后跟函数名一样，它被隐式的转换为一个函数指针。
3. 在第17行，取地址符作用于add之前，即&add，返回这个函数的地址，之后又得到一个函数指针。
4. 18到19行，add不断地解引用自身，不断返回函数名，并被转换为函数指针。到最后，它们的结果都和函数名没有区别。


显然，这段代码不是优秀的实例代码。我们从中收获到了如下知识：其一，函数名会被隐式的转换为函数指针，就像作为参数传递的时候，数组名被隐式的转换为指针一样。在函数指针被要求当作输入的任何地方，都能够使用函数名。其二，解引用符*和取地址符&用在函数名之前基本上都是多余的。
