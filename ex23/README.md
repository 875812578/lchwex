# 说明

达夫设备那段代码本来要做的事情是：把from数组中的元素拷贝count个到to里面去。
于是有人会说，这个工作简单，不就这样吗：

```
void my_send(int *to,  int *from,  int count)
{
    for(int i = 0;i != count; ++i){
          *to++ = *from++;
    }
}
```

这段代码的确很简洁，也是正确的，而且生成的机器码也比send函数短很多。但是却忽略了一个因素：执行效率。计算一下就可以知 道，my_send函数里面的循环条件，即i和count的比较运算的次数，是达夫设备的8倍！在做整数赋值这种耗时很少的工作时，这种耗时相对较高的比较工作是会大大地影响函数整体的效率的。达夫设备则是一种非常巧妙的解决办法（当然，它利用到了编译器的一些实现上的工作），而且如果把8换成更大的数的话，效率就还可以提高！

它的思路是这样的：把原数组以8个int为单位分成若干个小组，复制的时候以小组为单位复制，即一次复制8个 int。也就是说，在my_send函数中以一次比较运算的代价换来1个int的复制，而在达夫设备中，却能以一次比较运算的代价换来8个int的复制。 而switch语句则是用来处理分组时剩下的不到8个的int（这些剩余的不是数组最后的，而是数组最开始的），很巧妙。

# 解谜


利用了C编译器对于某些语法是弱检查的特性。这就是可以将do while语法放入switch中的原因。
switch语句默认可以让你跳到指定的case，继续运行直到switch结束

达夫设备的工作机制：

代码的主体还是do-while循环，但这个循环的入口点并不一定是在do那里，而是由这个switch语句根据n，把循环的 入口定在了几个case标号那里。也就是说，程序的执行流程是：程序一开始顺序执行，当它执行到了switch的时候，就会根据n的值，直接跳转到 case n那里（从此，这个swicth语句就再也没有用了）。程序继续顺序执行，再当它执行到while那里时，就会判断循环条件。若为真，则while循环开 始，程序跳转到do那里开始执行循环（这时候由于已经没有了switch，所以后面的标号就变成普通标号了，即在没有goto语句的情况下就可以忽略掉这 些标号了）；为假，则退出循环，即程序中止。

# 为什么这样写代码？

这个小技巧的目的是为了手动编写“循环展开”。大而长的循环会变的很慢，所以提升速度的一个方法就是找到循环中某个固定的部分，之后在循环中复制代码。

达夫设备将循环展开为8个迭代块。现在一般都不这么写代码，现代编译器已经帮你做了这些事了。
