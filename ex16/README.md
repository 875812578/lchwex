# 指针函数

当一个函数声明其返回值为一个指针时，实际上就是返回一个地址给调用函数，以用于需要指针或地址的表达式中。

格式：

    类型说明符 * 函数名(参数)

当然了，由于返回的是一个地址，所以类型说明符一般都是int。

例如：

```
int *GetDate();  
int * aaa(int,int);
```

# 结构体内存对齐

在C语言中，结构体是种复合数据类型，其构成元素既可以是基本数据类型(如int、long、float等)的变量，也可以是一些复合数据类型(如数组、结构体、联合等)的数据单元。编译器为结构体的每个成员按照其自然边界(alignment)分配空间。各成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。

字节对齐的问题主要就是针对结构体。


```
struct A{
    int    a;
    char   b;
    short  c;
};
struct B{
    char   b;
    int    a;
    short  c;
};
```
已知32位机器上各数据类型的长度为：

- char为1字节
- short为2字节
- int为4字节
- long为4字节
- float为4字节
- double为8字节

那么上面两个结构体大小如何呢？

结果是：

- sizeof(strcut A)值为8
- sizeof(struct B)的值却是12

结构体A中包含一个4字节的int数据，一个1字节char数据和一个2字节short数据；B也一样。按理说A和B大小应该都是7字节。之所以出现上述结果，就是因为编译器要对数据成员在空间上进行对齐。

### 对齐准则

 先来看四个重要的基本概念：

 1) 数据类型自身的对齐值：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节。

 2) 结构体或类的自身对齐值：其成员中自身对齐值最大的那个值。

 3) 指定对齐值：#pragma pack (value)时的指定对齐值value。

 4) 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。

 结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整(即结构体成员变量占用总长度为结构体有效对齐值的整数倍)。

 假设B从地址空间0x0000开始存放，且指定对齐值默认为4(4字节对齐)。成员变量b的自身对齐值是1，比默认指定对齐值4小，所以其有效对齐值为1，其存放地址0x0000符合0x0000%1=0。成员变量a自身对齐值为4，所以有效对齐值也为4，只能存放在起始地址为0x0004~0x0007四个连续的字节空间中，符合0x0004%4=0且紧靠第一个变量。变量c自身对齐值为 2，所以有效对齐值也是2，可存放在0x0008~0x0009两个字节空间中，符合0x0008%2=0。所以从0x0000~0x0009存放的都是B内容。

 再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b)所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求， 0x0000~0x0009=10字节，(10＋2)％4＝0。所以0x0000A~0x000B也为结构体B所占用。故B从0x0000到0x000B 共有12个字节，sizeof(struct B)=12。

 之所以编译器在后面补充2个字节，是为了实现结构数组的存取效率。试想如果定义一个结构B的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢？按照数组的定义，数组中所有元素都紧挨着。如果我们不把结构体大小补充为4的整数倍，那么下一个结构的起始地址将是0x0000A，这显然不能满足结构的地址对齐。因此要把结构体补充成有效对齐大小的整数倍。其实对于char/short/int/float/double等已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知，所以他们的自身对齐值也就已知。

 # struct问题

```
struct test * fun(void);

struct test
{
	int num;
};

int main(void)
{
	struct test * p;

	p = fun();

	printf("*p->num = %d\n", p->num);

	printf("Execute success!");
	getchar();
	return 0;
}

struct test * fun(void)
{
	struct test t;
	t.num = 20;
	return &t;
}
```
如上面程序所示，我在函数中定义了一个结构体并进行赋值，然后将其地址传递给主函数并打印p->num的值为20。
问题来了，函数在调用结束后里面的东西不是都回收吗？怎么结构体的东西还在呢？

回答：

自动变量（automatic variable）在离开 block 后就被标记为“这块内存可以继续重新使用”，也就是其内存并不会被擦除，有可能可以读取，但不能保证其内容永远存在，也许过两秒读出来数据就不对头了。你要知道擦除内存是个开销比较大的行为。在某些操作系统上，如 Linux，访问这块内存会引发段错误（segment fault）。值得指出的是这是个很明显的UB（undefined behavior，未定义行为），所以编译器在优化代码时可以做出任意行为。在 gcc 开了 O3 的情况下，这个函数直接返回 NULL（汇编代码是 xor %eax, %eax 然后 retq）。也就是说，如果在调试模式下可以读出来这块内存，也许你改成发布模式，就直接崩溃了！
